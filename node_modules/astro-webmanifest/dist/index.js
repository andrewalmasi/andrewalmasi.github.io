// src/index.ts
import { ZodError } from "zod";

// ../utils/src/is-object-empty.ts
var isObjectEmpty = (o) => {
  if (!o) {
    return true;
  }
  if (Array.isArray(o)) {
    return o.length === 0;
  }
  return Object.keys(o).length === 0 && Object.getPrototypeOf(o) === Object.prototype;
};

// ../utils/src/is-number.ts
function isNumber(num) {
  return typeof num === "number" || !isNaN(num);
}

// ../utils/src/is-valid-url-ex.ts
var isValidUrlEx = (s) => {
  if (typeof s !== "string" || !s) {
    return false;
  }
  if (isNumber(s)) {
    return false;
  }
  try {
    const dummy = new URL(s, "http://a");
    return true;
  } catch {
    return false;
  }
};

// ../utils/src/logger.ts
var Logger = class {
  constructor(packageName2) {
    this.colors = {
      reset: "\x1B[0m",
      fg: {
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m"
      }
    };
    this.packageName = packageName2;
  }
  log(msg, prefix = "") {
    const s = msg.join("\n");
    console.log(`%s${this.packageName}:%s ${s}
`, prefix, prefix ? this.colors.reset : "");
  }
  info(...msg) {
    this.log(msg);
  }
  success(...msg) {
    this.log(msg, this.colors.fg.green);
  }
  warn(...msg) {
    this.log(["Skipped!", ...msg], this.colors.fg.yellow);
  }
  error(...msg) {
    this.log(["Failed!", ...msg], this.colors.fg.red);
  }
};

// ../utils/src/is-file-exists-sync.ts
import fs from "node:fs";
function isFileExistsSync(file) {
  try {
    return fs.statSync(file).isFile();
  } catch (e) {
    if (e.code !== "ENOENT") {
      throw e;
    }
    return false;
  }
}

// ../utils/src/is-dir-exists.ts
import { promises as fs2 } from "node:fs";
async function isDirExists(dir) {
  try {
    const stats = await fs2.stat(dir);
    return stats.isDirectory();
  } catch (err) {
    if (err.code !== "ENOENT") {
      throw err;
    }
    return false;
  }
}

// src/data/pkg-name.ts
var packageName = "astro-webmanifest";

// src/helpers/is-icon-square.ts
import sharp from "sharp";
async function isIconSquare(icon) {
  try {
    const metadata = await sharp(icon).metadata();
    return metadata.width === metadata.height;
  } catch (err) {
    console.error(err);
    return void 0;
  }
}

// src/validate-options.ts
import { z as z2 } from "zod";
import isValidFilename from "valid-filename";

// src/config-defaults.ts
var WEBMANIFEST_CONFIG_DEFAULTS = {
  config: {
    outfile: "manifest.webmanifest",
    createFavicon: true,
    insertFaviconLinks: true,
    insertManifestLink: true,
    crossOrigin: "anonymous",
    insertThemeColorMeta: true,
    insertAppleTouchLinks: false,
    indent: "    ",
    eol: "\n"
  }
};

// src/constants.ts
var crossOriginValues = ["anonymous", "use-credentials"];
var iconPurposeValues = ["badge", "maskable", "any", "monochrome"];
var applicationPlatformValues = [
  "wide",
  "narrow",
  "amazon",
  "play",
  "itunes",
  "microsoft",
  "webapp",
  "f-droid",
  "chromeos",
  "ios",
  "kaios",
  "macos",
  "windows",
  "windows10x",
  "xbox",
  "chrome_web_store"
];
var displayValues = ["fullscreen", "standalone", "minimal-ui", "browser"];
var orientationValues = [
  "any",
  "natural",
  "landscape",
  "landscape-primary",
  "landscape-secondary",
  "portrait",
  "portrait-primary",
  "portrait-secondary"
];
var dirValues = ["auto", "ltr", "rtl"];

// src/manifest-schema.ts
import { string, z } from "zod";

// src/helpers/is-valid-size.ts
var isValidSize = (size) => {
  if (!size || size === "any") {
    return true;
  }
  const arrSpace = size.split(" ");
  for (const item of arrSpace) {
    const arr = item.split(/[xX]/);
    if (arr.length !== 2) {
      return false;
    }
    for (const el of arr) {
      if (isNaN(el)) {
        return false;
      }
    }
  }
  return true;
};
var is_valid_size_default = isValidSize;

// src/manifest-schema.ts
var schemaRelativeUrl = z.string().refine((val) => !val || isValidUrlEx(val), { message: "Not valid URL" });
var schemaRelativeUrlRequired = z.string().min(1).refine((val) => isValidUrlEx(val), { message: "Not valid URL" });
var isValidIconPurpose = (purpose) => {
  const arr = purpose.split(" ");
  for (const p of arr) {
    if (iconPurposeValues.indexOf(p) === -1) {
      return false;
    }
  }
  return true;
};
var schemaIcon = {
  src: z.string().min(1),
  sizes: z.string().refine((val) => !val || is_valid_size_default(val), { message: "Not valid sizes" }).optional(),
  type: z.string().optional(),
  purpose: z.string().refine((val) => !val || isValidIconPurpose(val), { message: "Not valid purpose" }).optional()
};
var manifestSchema = {
  name: z.string().min(1),
  short_name: z.string().optional(),
  description: z.string().optional(),
  categories: z.string().array().optional(),
  lang: z.string().optional(),
  dir: z.enum(dirValues).optional(),
  iarc_rating_id: z.string().optional(),
  id: z.string().optional(),
  start_url: schemaRelativeUrl.optional(),
  scope: schemaRelativeUrl.optional(),
  theme_color: z.string().optional(),
  background_color: z.string().optional(),
  display: z.enum(displayValues).optional(),
  display_override: z.enum(displayValues).array().optional(),
  orientation: z.enum(orientationValues).optional(),
  protocol_handlers: z.object({
    protocol: z.string().min(1),
    url: schemaRelativeUrlRequired
  }).array().optional(),
  prefer_related_applications: z.boolean().optional(),
  related_applications: z.object({
    id: z.string().optional(),
    platform: z.enum(applicationPlatformValues),
    url: z.string().url()
  }).array().optional(),
  screenshots: z.object({
    ...schemaIcon,
    platform: z.enum(applicationPlatformValues).optional(),
    label: z.string().optional()
  }).array().optional(),
  icons: z.object(schemaIcon).array().optional(),
  shortcuts: z.object({
    name: z.string().min(1),
    short_name: z.string().optional(),
    description: z.string().optional(),
    url: schemaRelativeUrlRequired,
    min_version: z.string().optional(),
    fingerprints: z.object({
      name: z.string().min(1),
      type: z.string().min(1)
    }).array().optional(),
    icons: z.object(schemaIcon).array().optional()
  }).array().optional(),
  icon: string().refine((val) => !val || isFileExistsSync(val), { message: "File doesn't exist" }).optional()
};

// src/validate-options.ts
var validateOptions = (opts) => {
  const getLocalesValidator = () => {
    const result2 = {};
    if ((opts == null ? void 0 : opts.locales) && !isObjectEmpty(opts.locales)) {
      Object.keys(opts.locales).forEach((locale) => {
        result2[locale] = z2.object(manifestSchema);
      });
    }
    return result2;
  };
  const schema = z2.object({
    ...manifestSchema,
    config: z2.object({
      iconPurpose: z2.enum(iconPurposeValues).array().optional(),
      createFavicon: z2.boolean().optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.createFavicon),
      insertFaviconLinks: z2.boolean().optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.insertFaviconLinks),
      insertManifestLink: z2.boolean().optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.insertManifestLink),
      crossOrigin: z2.enum(crossOriginValues).optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.crossOrigin),
      insertThemeColorMeta: z2.boolean().optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.insertThemeColorMeta),
      insertAppleTouchLinks: z2.boolean().optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.insertAppleTouchLinks),
      indent: z2.string().optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.indent),
      eol: z2.string().optional().default(WEBMANIFEST_CONFIG_DEFAULTS.config.eol),
      outfile: z2.string().min(1).optional().refine((val) => !val || isValidFilename(val), { message: "Not valid file name" }).default(WEBMANIFEST_CONFIG_DEFAULTS.config.outfile)
    }).default(WEBMANIFEST_CONFIG_DEFAULTS.config),
    locales: z2.object(getLocalesValidator()).optional()
  }).default(WEBMANIFEST_CONFIG_DEFAULTS);
  const result = schema.parse(opts);
  return result;
};

// src/process-favicon.ts
import sharp3 from "sharp";
import fs4 from "node:fs";

// src/helpers/generate-icon.ts
import path from "node:path";
import sharp2 from "sharp";
import { promises as fs3 } from "node:fs";
async function generateIcon(icon, srcIcon, dir) {
  const { sizes = "" } = icon;
  if (!sizes || sizes === "any") {
    return void 0;
  }
  if (sizes.split(" ").length > 1) {
    return void 0;
  }
  const arr = sizes.split(/[xX]/);
  if (arr.length > 2) {
    return void 0;
  }
  const size = parseInt(arr[0]);
  const density = Math.min(2400, Math.max(1, size));
  const sharpIcon = sharp2(srcIcon, { density });
  const { data, info } = await sharpIcon.resize({
    width: size,
    height: size,
    fit: "contain",
    background: { r: 255, g: 255, b: 255, alpha: 0 }
  }).toBuffer({ resolveWithObject: true });
  const out = new URL(icon.src, dir);
  const dirname = path.dirname(out.href);
  if (!await isDirExists(dirname)) {
    await fs3.mkdir(new URL(dirname), { recursive: true });
  }
  await fs3.writeFile(out, data);
  return info;
}

// src/helpers/process-icon-set.ts
async function processIconsSet(iconSet, srcIcon, dir) {
  if (!iconSet) {
    return;
  }
  for (const dstIcon of iconSet) {
    await generateIcon(dstIcon, srcIcon, dir);
  }
}

// src/default-icons.ts
var favicons = [
  {
    src: "favicon-32x32.png",
    sizes: "32x32",
    type: "image/png"
  }
];
var defaultIcons = [
  {
    src: "icons/icon-48x48.png",
    sizes: "48x48",
    type: "image/png"
  },
  {
    src: "icons/icon-72x72.png",
    sizes: "72x72",
    type: "image/png"
  },
  {
    src: "icons/icon-96x96.png",
    sizes: "96x96",
    type: "image/png"
  },
  {
    src: "icons/icon-144x144.png",
    sizes: "144x144",
    type: "image/png"
  },
  {
    src: "icons/icon-192x192.png",
    sizes: "192x192",
    type: "image/png"
  },
  {
    src: "icons/icon-256x256.png",
    sizes: "256x256",
    type: "image/png"
  },
  {
    src: "icons/icon-384x384.png",
    sizes: "384x384",
    type: "image/png"
  },
  {
    src: "icons/icon-512x512.png",
    sizes: "512x512",
    type: "image/png"
  }
];

// src/process-favicon.ts
async function processFavicon(srcIcon, dir) {
  const metadata = await sharp3(srcIcon).metadata();
  await processIconsSet(favicons, srcIcon, dir);
  if (metadata.format === "svg") {
    fs4.copyFileSync(srcIcon, new URL("favicon.svg", dir));
  }
}

// src/create-manifest.ts
import fs5 from "node:fs";

// src/get-manifest.ts
var getManifest = ({ icon, config, locales, name, icons, shortcuts, ...opts } = { name: "" }) => {
  const add = (config == null ? void 0 : config.iconPurpose) || [];
  const getIcon = ({ purpose, ...rest }) => {
    const result = { ...rest };
    const src = (purpose == null ? void 0 : purpose.split(" ")) || [];
    const arr = [.../* @__PURE__ */ new Set([...add, ...src])];
    if (arr.length > 0) {
      result.purpose = arr.join(" ");
    }
    return result;
  };
  const getShortcut = ({ icons: shortcutIcons, ...rest }) => {
    const result = { ...rest };
    if (shortcutIcons) {
      result.icons = shortcutIcons.map(getIcon);
    }
    return result;
  };
  const manifest = {
    name,
    icons: (icons || defaultIcons).map(getIcon),
    ...opts
  };
  if (shortcuts) {
    manifest.shortcuts = shortcuts.map(getShortcut);
  }
  return manifest;
};

// src/helpers/localize-outfile.ts
var localizeOutfile = (outfile, locale) => {
  if (!locale) {
    return outfile;
  }
  const a = outfile.split(".");
  a[0] = `${a[0]}-${locale}`;
  return a.join(".");
};
var localize_outfile_default = localizeOutfile;

// src/create-manifest.ts
async function createManifest(opts, outfile, dir, logger, locale = "") {
  const manifest = getManifest(opts);
  if (opts == null ? void 0 : opts.icon) {
    await processIconsSet(manifest.icons, opts.icon, dir);
  }
  const localized = localize_outfile_default(outfile, locale);
  fs5.writeFileSync(new URL(localized, dir), JSON.stringify(manifest, null, 2));
  logger.success(`\`${localized}\` is created.`);
  return {
    locale,
    outfile: localized,
    manifest
  };
}

// src/process-pages.ts
import { promises as fs6 } from "node:fs";
var addTailSlash = (s) => s.endsWith("/") ? s : s + "/";
var removeHeadSlash = (s) => s.replace(/^\/+/, "");
var removeTrailingSlash = (s) => s.replace(/\/+$/, "");
var DEFAULT_LOCALE = "";
var getLocaleFromPathname = (s) => {
  if (!s) {
    return DEFAULT_LOCALE;
  }
  const [locale] = s.split("/");
  return locale;
};
var getFileDir = (pathname) => {
  const name = addTailSlash(pathname);
  const file = name === "404/" ? "404.html" : `${name}index.html`;
  return removeHeadSlash(file);
};
var getFileFile = (pathname) => {
  if (!pathname) {
    return "index.html";
  }
  return `${removeTrailingSlash(pathname)}.html`;
};
async function processPages(pages, dir, heads, buildFormat, logger) {
  if (buildFormat !== "directory" && buildFormat !== "file") {
    throw new Error(`Unsupported build.format: '${buildFormat}' in your astro.config`);
  }
  const getData = (locale) => {
    const data = heads[locale] || heads[DEFAULT_LOCALE];
    if (!data) {
      throw new Error("Fatal in getData: empty `data`");
    }
    return data;
  };
  let insertedCount = 0;
  const HEAD_END_TAG = "</head>";
  for (const page of pages) {
    const locale = getLocaleFromPathname(page.pathname);
    const fileUrl = new URL(buildFormat === "directory" ? getFileDir(page.pathname) : getFileFile(page.pathname), dir);
    const content = await fs6.readFile(fileUrl, "utf-8");
    const index = content.indexOf(HEAD_END_TAG);
    if (index === -1) {
      logger.info(`Cannot insert links. Reason: no <head> section in \`${fileUrl.pathname}\`.`);
    } else {
      const inlined = content.substring(0, index) + getData(locale) + content.substring(index);
      await fs6.writeFile(fileUrl, inlined, "utf-8");
      insertedCount += 1;
    }
  }
  return insertedCount;
}

// src/get-heads.ts
var getHeads = (opts, base, results) => {
  const { icon: srcIcon, config: cfg } = opts;
  const heads = {};
  const addBasePath = (path2) => {
    const s = path2.startsWith("/") ? path2 : `/${path2}`;
    return base === "/" ? s : `${base}${s}`;
  };
  for (const {
    locale,
    outfile: manifestFileName,
    manifest: { icons, theme_color }
  } of results) {
    const headComponents = [];
    if (srcIcon && (cfg == null ? void 0 : cfg.createFavicon) && cfg.insertFaviconLinks) {
      favicons.forEach((favicon) => {
        headComponents.push(`<link rel="icon" href="${addBasePath(favicon.src)}" type="image/png">`);
      });
      if (srcIcon == null ? void 0 : srcIcon.endsWith(".svg")) {
        headComponents.push(`<link rel="icon" href="${addBasePath("favicon.svg")}" type="image/svg+xml">`);
      }
    }
    if (theme_color && (cfg == null ? void 0 : cfg.insertThemeColorMeta)) {
      headComponents.push(`<meta name="theme-color" content="${theme_color}">`);
    }
    if (cfg == null ? void 0 : cfg.insertManifestLink) {
      headComponents.push(`<link rel="manifest" href="${addBasePath(manifestFileName)}" crossorigin="${cfg.crossOrigin}">`);
    }
    if (cfg == null ? void 0 : cfg.insertAppleTouchLinks) {
      icons == null ? void 0 : icons.forEach(({ sizes, src }) => {
        headComponents.push(`<link rel="apple-touch-icon" sizes="${sizes}" href="${addBasePath(src)}">`);
      });
    }
    if (headComponents.length > 0) {
      heads[locale] = headComponents.map((item) => (cfg == null ? void 0 : cfg.indent) + item + (cfg == null ? void 0 : cfg.eol)).join("");
    }
  }
  return heads;
};

// src/on-build-done.ts
var onBuildDone = async (pluginOptions, config, dir, pages, logger) => {
  var _a, _b, _c;
  const checkIconDimension = async (icon) => {
    if (icon && !await isIconSquare(icon)) {
      logger.info(`
        The icon(${icon}) provided is not square.
        The generated icons will be square and for the best results it's recommend to provide a square icon.
        `);
    }
  };
  const opts = validateOptions(pluginOptions);
  await checkIconDimension(opts.icon);
  if (opts.locales) {
    for (const { icon } of Object.values(opts.locales)) {
      await checkIconDimension(icon);
    }
  }
  if (opts.icon && ((_a = opts.config) == null ? void 0 : _a.createFavicon)) {
    await processFavicon(opts.icon, dir);
  }
  const results = [];
  results.push(await createManifest(opts, (_b = opts.config) == null ? void 0 : _b.outfile, dir, logger));
  if (opts.locales) {
    const arr = Object.entries(opts.locales);
    for (const [locale, entry] of arr) {
      results.push(await createManifest({ ...opts, ...entry }, (_c = opts.config) == null ? void 0 : _c.outfile, dir, logger, locale));
    }
  }
  if (pages.length === 0) {
    return;
  }
  const heads = getHeads(opts, config.base, results);
  if (isObjectEmpty(heads)) {
    return;
  }
  const insertedCount = await processPages(pages, dir, heads, config.build.format, logger);
  if (insertedCount > 0) {
    logger.success(`Webmanifest links are inserted into <head> section of generated pages (${insertedCount} of ${pages.length}).`);
  }
};
var on_build_done_default = onBuildDone;

// src/index.ts
function formatConfigErrorMessage(err) {
  const errorList = err.issues.map((issue) => `${issue.path.join(".")}  ${issue.message + "."}`);
  return errorList.join("\n");
}
var createPlugin = (options) => {
  let config;
  return {
    name: packageName,
    hooks: {
      "astro:config:done": async ({ config: cfg }) => {
        config = cfg;
      },
      "astro:build:done": async ({ dir, pages }) => {
        if (!options) {
          throw new Error(`${packageName}: no configurations found. Provide options in "astro.config.*"`);
        }
        const logger = new Logger(packageName);
        try {
          await on_build_done_default(options, config, dir, pages, logger);
        } catch (err) {
          if (err instanceof ZodError) {
            logger.warn(formatConfigErrorMessage(err));
          } else {
            throw err;
          }
        }
      }
    }
  };
};
var src_default = createPlugin;
export {
  src_default as default
};
